템플릿 메서드 : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
-> 전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 메서드의 코드 중복을 최소화 할 때 유용


팩토리 : 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴
-> 객체생성 변화(생성,수정,삭제)가 발생했을 때 코드 수정이 용이

싱글톤 : 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴
-> 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 인스턴스를 만들어 사용해 메모리 낭비를 방지
-> 스프링실행시 Bin(생성자) 폴더에서 사용(한번만 메모리를 할당하면 그 이후에 변경될 일이 없음)

mvc (모델 - 뷰 - 컨트롤러) :  
1. 모델 : 데이터와 비즈니스 로직을 관리
2. 뷰 : 레이아웃과 화면을 처리
3. 컨트롤러 : 명령을 모델과 뷰로 전달 (사용자로부터 입력에 대한 응답을로 모델/뷰를 업데이트 하는 로직을 포함)

mvc모델 사용 이유 -> '분업'을 하는게 호율적인 작업방법 / 유지보수, 확장성, 유연성 증가 의존성 감소 / 중복코딩 문제점 사라짐

mvvm(모델 - 뷰 - 뷰 모델) : 
1. 뷰 : UI 로직을 포함하되 비즈니스 로직은 포함 X
2. 뷰 모델 : 뷰가 사용할 메서드와 필드를 구현, 뷰에게 상태변화를 알림. 
3. 모델 : 데이터와 비즈니스 로직을 관리

mvp(모델 - 뷰 - 프레젠터) : -> 모델과 뷰를 완전히 분리해서 사용하기 위함(mvc의 단점 : 뷰와 모델의 결합도가 높다를 개선)
1. 뷰 : UI로직을 포함하되 비즈니스 로직은 포함 X
2. 프레젠터 : 본질적으로는 MVC의 컨트롤러와 같지만, 뷰에 연결되는 것이 아니라 인터페이스로 연결된다는 점이 다르다. 뷰와 모델 사이에서 자료 전달 역할
3. 모델 : 데이터 및 상태에 대한 비지니스 로직을 수행
-> 프리젠터는 일대일 관계로 인해 각각의 뷰 마다 프리젠터가 존재한다. 
mvc모델과 차이점 : 뷰와 모델끼리의 결합도가 전혀 없다. 반드시 프레젠터를 통해서만 데이터를 주고받을 수 있다.

*비즈니스 로직 : 컴퓨터 프로그램의 규칙에 따라 데이터를 생성 표시 저장 변경하는 부분을 말한다.

데커레이터 : 객체의 결합을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴
-> 추가할 수 있는 기능의 종류가 많은 경우 각 추가 기능을 데코레이터 클래스로 정의한 후 필요한 데코레이터 객체를 조합함으로써 추가 기능의 조합을 설계 하는 방식
-> override로 함수를 재정의 하므로 기능이 달라진 함수를 다른 클래스에서 사용하기 용이

커맨드 : 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
-> 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자(Invoker) 클래스와 실제 기능을 실행하는 수신자(Receiver)클래스 사이의 의존성을 제거
-> 각 객체들이 수정되어도 다른 객체가 영향을 받지 않는다.

스트래티지 : 같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴
-> 전략을 쉽게 바꿀 수 있도록 하는 디자인 패턴

옵저버 : 어떤 객체의 상태가 변할 때 그와 연관된 객체 들에게 알림을 보내는 디자인 패턴
-> 기상청 실시간 날씨정보
